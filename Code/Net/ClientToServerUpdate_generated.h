// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CLIENTTOSERVERUPDATE_FLATBUFFPACKET_H_
#define FLATBUFFERS_GENERATED_CLIENTTOSERVERUPDATE_FLATBUFFPACKET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");


namespace FlatBuffPacket {

struct OptInt;

struct Vec2;

struct PlayerInput;

struct PlayerInputsSynchronizer;
struct PlayerInputsSynchronizerBuilder;

struct ClientToServerUpdate;
struct ClientToServerUpdateBuilder;

inline const ::flatbuffers::TypeTable *OptIntTypeTable();

inline const ::flatbuffers::TypeTable *Vec2TypeTable();

inline const ::flatbuffers::TypeTable *PlayerInputTypeTable();

inline const ::flatbuffers::TypeTable *PlayerInputsSynchronizerTypeTable();

inline const ::flatbuffers::TypeTable *ClientToServerUpdateTypeTable();

enum InputFlags : int8_t {
  InputFlags_None = 0,
  InputFlags_MoveLeft = 1,
  InputFlags_MoveRight = 2,
  InputFlags_MoveForward = 4,
  InputFlags_MoveBackward = 8,
  InputFlags_MIN = InputFlags_None,
  InputFlags_MAX = InputFlags_MoveBackward
};

inline const InputFlags (&EnumValuesInputFlags())[5] {
  static const InputFlags values[] = {
    InputFlags_None,
    InputFlags_MoveLeft,
    InputFlags_MoveRight,
    InputFlags_MoveForward,
    InputFlags_MoveBackward
  };
  return values;
}

inline const char * const *EnumNamesInputFlags() {
  static const char * const names[10] = {
    "None",
    "MoveLeft",
    "MoveRight",
    "",
    "MoveForward",
    "",
    "",
    "",
    "MoveBackward",
    nullptr
  };
  return names;
}

inline const char *EnumNameInputFlags(InputFlags e) {
  if (::flatbuffers::IsOutRange(e, InputFlags_None, InputFlags_MoveBackward)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesInputFlags()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OptInt FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t i_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OptIntTypeTable();
  }
  OptInt()
      : i_(0) {
  }
  OptInt(int32_t _i)
      : i_(::flatbuffers::EndianScalar(_i)) {
  }
  int32_t i() const {
    return ::flatbuffers::EndianScalar(i_);
  }
};
FLATBUFFERS_STRUCT_END(OptInt, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return Vec2TypeTable();
  }
  Vec2()
      : x_(0),
        y_(0) {
  }
  Vec2(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PlayerInput FLATBUFFERS_FINAL_CLASS {
 private:
  FlatBuffPacket::Vec2 mouse_delta_;
  int8_t player_actions_;
  int8_t padding0__;  int16_t padding1__;

 public:
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlayerInputTypeTable();
  }
  PlayerInput()
      : mouse_delta_(),
        player_actions_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  PlayerInput(const FlatBuffPacket::Vec2 &_mouse_delta, FlatBuffPacket::InputFlags _player_actions)
      : mouse_delta_(_mouse_delta),
        player_actions_(::flatbuffers::EndianScalar(static_cast<int8_t>(_player_actions))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  const FlatBuffPacket::Vec2 &mouse_delta() const {
    return mouse_delta_;
  }
  FlatBuffPacket::InputFlags player_actions() const {
    return static_cast<FlatBuffPacket::InputFlags>(::flatbuffers::EndianScalar(player_actions_));
  }
};
FLATBUFFERS_STRUCT_END(PlayerInput, 12);

struct PlayerInputsSynchronizer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerInputsSynchronizerBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return PlayerInputsSynchronizerTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICK_NUM = 4,
    VT_TICK_COUNT = 6,
    VT_INPUTS = 8
  };
  const FlatBuffPacket::OptInt *tick_num() const {
    return GetStruct<const FlatBuffPacket::OptInt *>(VT_TICK_NUM);
  }
  int32_t tick_count() const {
    return GetField<int32_t>(VT_TICK_COUNT, 0);
  }
  const ::flatbuffers::Vector<const FlatBuffPacket::PlayerInput *> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<const FlatBuffPacket::PlayerInput *> *>(VT_INPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<FlatBuffPacket::OptInt>(verifier, VT_TICK_NUM, 4) &&
           VerifyField<int32_t>(verifier, VT_TICK_COUNT, 4) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.EndTable();
  }
};

struct PlayerInputsSynchronizerBuilder {
  typedef PlayerInputsSynchronizer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tick_num(const FlatBuffPacket::OptInt *tick_num) {
    fbb_.AddStruct(PlayerInputsSynchronizer::VT_TICK_NUM, tick_num);
  }
  void add_tick_count(int32_t tick_count) {
    fbb_.AddElement<int32_t>(PlayerInputsSynchronizer::VT_TICK_COUNT, tick_count, 0);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<const FlatBuffPacket::PlayerInput *>> inputs) {
    fbb_.AddOffset(PlayerInputsSynchronizer::VT_INPUTS, inputs);
  }
  explicit PlayerInputsSynchronizerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerInputsSynchronizer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerInputsSynchronizer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerInputsSynchronizer> CreatePlayerInputsSynchronizer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const FlatBuffPacket::OptInt *tick_num = nullptr,
    int32_t tick_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const FlatBuffPacket::PlayerInput *>> inputs = 0) {
  PlayerInputsSynchronizerBuilder builder_(_fbb);
  builder_.add_inputs(inputs);
  builder_.add_tick_count(tick_count);
  builder_.add_tick_num(tick_num);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerInputsSynchronizer> CreatePlayerInputsSynchronizerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const FlatBuffPacket::OptInt *tick_num = nullptr,
    int32_t tick_count = 0,
    const std::vector<FlatBuffPacket::PlayerInput> *inputs = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVectorOfStructs<FlatBuffPacket::PlayerInput>(*inputs) : 0;
  return FlatBuffPacket::CreatePlayerInputsSynchronizer(
      _fbb,
      tick_num,
      tick_count,
      inputs__);
}

struct ClientToServerUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClientToServerUpdateBuilder Builder;
  static const ::flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ClientToServerUpdateTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_NUM = 4,
    VT_PLAYER_SYNCHRONIZERS = 6
  };
  int8_t player_num() const {
    return GetField<int8_t>(VT_PLAYER_NUM, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>> *player_synchronizers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>> *>(VT_PLAYER_SYNCHRONIZERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PLAYER_NUM, 1) &&
           VerifyOffset(verifier, VT_PLAYER_SYNCHRONIZERS) &&
           verifier.VerifyVector(player_synchronizers()) &&
           verifier.VerifyVectorOfTables(player_synchronizers()) &&
           verifier.EndTable();
  }
};

struct ClientToServerUpdateBuilder {
  typedef ClientToServerUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_num(int8_t player_num) {
    fbb_.AddElement<int8_t>(ClientToServerUpdate::VT_PLAYER_NUM, player_num, 0);
  }
  void add_player_synchronizers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>>> player_synchronizers) {
    fbb_.AddOffset(ClientToServerUpdate::VT_PLAYER_SYNCHRONIZERS, player_synchronizers);
  }
  explicit ClientToServerUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClientToServerUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClientToServerUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClientToServerUpdate> CreateClientToServerUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t player_num = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>>> player_synchronizers = 0) {
  ClientToServerUpdateBuilder builder_(_fbb);
  builder_.add_player_synchronizers(player_synchronizers);
  builder_.add_player_num(player_num);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientToServerUpdate> CreateClientToServerUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t player_num = 0,
    const std::vector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>> *player_synchronizers = nullptr) {
  auto player_synchronizers__ = player_synchronizers ? _fbb.CreateVector<::flatbuffers::Offset<FlatBuffPacket::PlayerInputsSynchronizer>>(*player_synchronizers) : 0;
  return FlatBuffPacket::CreateClientToServerUpdate(
      _fbb,
      player_num,
      player_synchronizers__);
}

inline const ::flatbuffers::TypeTable *InputFlagsTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FlatBuffPacket::InputFlagsTypeTable
  };
  static const int64_t values[] = { 0, 1, 2, 4, 8 };
  static const char * const names[] = {
    "None",
    "MoveLeft",
    "MoveRight",
    "MoveForward",
    "MoveBackward"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_ENUM, 5, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *OptIntTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_INT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4 };
  static const char * const names[] = {
    "i"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 1, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *Vec2TypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_FLOAT, 0, -1 },
    { ::flatbuffers::ET_FLOAT, 0, -1 }
  };
  static const int64_t values[] = { 0, 4, 8 };
  static const char * const names[] = {
    "x",
    "y"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, nullptr, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PlayerInputTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_CHAR, 0, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FlatBuffPacket::Vec2TypeTable,
    FlatBuffPacket::InputFlagsTypeTable
  };
  static const int64_t values[] = { 0, 8, 12 };
  static const char * const names[] = {
    "mouse_delta",
    "player_actions"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_STRUCT, 2, type_codes, type_refs, nullptr, values, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *PlayerInputsSynchronizerTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_SEQUENCE, 0, 0 },
    { ::flatbuffers::ET_INT, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FlatBuffPacket::OptIntTypeTable,
    FlatBuffPacket::PlayerInputTypeTable
  };
  static const char * const names[] = {
    "tick_num",
    "tick_count",
    "inputs"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const ::flatbuffers::TypeTable *ClientToServerUpdateTypeTable() {
  static const ::flatbuffers::TypeCode type_codes[] = {
    { ::flatbuffers::ET_CHAR, 0, -1 },
    { ::flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const ::flatbuffers::TypeFunction type_refs[] = {
    FlatBuffPacket::PlayerInputsSynchronizerTypeTable
  };
  static const char * const names[] = {
    "player_num",
    "player_synchronizers"
  };
  static const ::flatbuffers::TypeTable tt = {
    ::flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const FlatBuffPacket::ClientToServerUpdate *GetClientToServerUpdate(const void *buf) {
  return ::flatbuffers::GetRoot<FlatBuffPacket::ClientToServerUpdate>(buf);
}

inline const FlatBuffPacket::ClientToServerUpdate *GetSizePrefixedClientToServerUpdate(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<FlatBuffPacket::ClientToServerUpdate>(buf);
}

inline bool VerifyClientToServerUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatBuffPacket::ClientToServerUpdate>(nullptr);
}

inline bool VerifySizePrefixedClientToServerUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatBuffPacket::ClientToServerUpdate>(nullptr);
}

inline void FinishClientToServerUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatBuffPacket::ClientToServerUpdate> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedClientToServerUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<FlatBuffPacket::ClientToServerUpdate> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatBuffPacket

#endif  // FLATBUFFERS_GENERATED_CLIENTTOSERVERUPDATE_FLATBUFFPACKET_H_
